"""
JARVIS - Ollama-based conversational AI wrapper with session management and replay.

This module provides:
- Direct interface to Ollama's Jarvis model via subprocess
- Persistent JSON logging of all interactions
- Session tracking with unique IDs (ephemeral or named)
- Selective replay functionality (last:N turns or current session)
- Conversation mode enforcement

Session Structure:
  Ephemeral: Each run gets a unique SESSION_ID (default)
  Named: Multiple runs can share a SESSION_ID using --session <name> flag
  
  Named sessions persist in .sessions.json until manually deleted.
  Replay can be triggered explicitly with --replay flags.
  No automatic memory. No persistence between runs unless --session is used.
"""

import subprocess
import sys
import os
import json
import uuid
from datetime import datetime
from pathlib import Path

# ============================================================================
# Session Management
# ============================================================================

# Placeholder for SESSION_ID - will be assigned in __main__ based on CLI args
SESSION_ID: str
"""Unique identifier for this execution. Set in __main__ before run_jarvis() is called."""


def _get_log_dir() -> str:

MODE_ENFORCEMENT = """You must strictly follow the rules of any activated conversation mode.
These rules are mandatory constraints, not suggestions.

Do not narrate modes.
Do not ask permission to begin.
Do not ask clarifying questions before producing output if the active mode forbids it.

If Brainstorming Mode applies:
- Start by generating ideas immediately
- Provide multiple distinct ideas before asking any questions
- Do not ask "what's the concept" or similar gatekeeping questions

Respond to the user. Do not mention conversation modes or internal state.
"""
"""System constraint injected when --mode flag is used. Enforces mode rules."""


# ============================================================================
# Logging Infrastructure
# ============================================================================

def _get_log_dir() -> str:
    """
    Resolve the log directory path.
    
    Logs are stored in: <workspace_root>/logs/
    One file per day: YYYY-MM-DD.log
    Format: newline-delimited JSON (NDJSON)
    
    Returns:
        str: Absolute path to the logs directory.
    """
    base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
    return os.path.join(base_dir, "logs")


def _append_daily_log(
    *,
    timestamp_iso: str,
    session_id: str,
    user_prompt: str,
    model_response: str,
    active_mode: str | None,
    replay_n: int | None,
    replay_session: bool,
) -> None:
    """
    Append a single interaction record to the daily log file.
    
    Each record captures:
    - ISO timestamp of the interaction
    - Session ID (shared by all turns in this run)
    - User input and model response
    - Active conversation mode (if any)
    - Replay metadata (whether and how replay was used)
    
    Log files are organized by date: YYYY-MM-DD.log
    Corrupt lines are silently skipped during reads.
    
    Args:
        timestamp_iso: ISO 8601 timestamp string (YYYY-MM-DDTHH:MM:SS)
        session_id: UUID of current session
        user_prompt: Raw user input (no modifications)
        model_response: Model output from Ollama
        active_mode: Name of conversation mode or None
        replay_n: If last:N was used, the value N; else None
        replay_session: True if --replay session was used; False otherwise
    """
    log_dir = _get_log_dir()
    os.makedirs(log_dir, exist_ok=True)

    # File per day: YYYY-MM-DD.log
    file_name = f"{timestamp_iso[:10]}.log"
    file_path = os.path.join(log_dir, file_name)

    # Build the record
    record = {
        "timestamp": timestamp_iso,
        "session_id": session_id,
        "active_mode": active_mode,
        "replay": {
            "enabled": replay_n is not None or replay_session,
            "count": replay_n,
            "session": replay_session,
        },
        "user_prompt": user_prompt,
        "model_response": model_response,
    }

    # Append as newline-delimited JSON
    with open(file_path, "a", encoding="utf-8", newline="\n") as f:
        f.write(json.dumps(record, ensure_ascii=False) + "\n")


# ============================================================================
# Replay Helpers
# ============================================================================

def get_last_n_entries(n: int) -> list[dict]:
    """
    Retrieve the last N interaction records from logs (chronological order).
    
    Scans log files in reverse chronological order (newest first).
    Stops as soon as N entries are found.
    Skips corrupt JSON lines silently.
    
    Args:
        n: Number of entries to retrieve
        
    Returns:
        list[dict]: List of log records, oldest to newest.
                   Empty list if no logs exist or n=0.
    """
    log_dir = _get_log_dir()
    if not os.path.exists(log_dir):
        return []

    log_files = sorted(Path(log_dir).glob("*.log"))
    if not log_files:
        return []

    entries: list[dict] = []

    # Walk logs backward (newest first)
    for log_file in reversed(log_files):
        with open(log_file, "r", encoding="utf-8") as f:
            lines = f.readlines()

        # Read lines backward within the file
        for line in reversed(lines):
            try:
                record = json.loads(line)
                entries.append(record)
                if len(entries) >= n:
                    return list(reversed(entries))  # Return oldest to newest
            except json.JSONDecodeError:
                continue

    return list(reversed(entries))


def get_session_entries(session_id: str) -> list[dict]:
    """
    Retrieve all interaction records from a specific session.
    
    Performs a linear scan across all log files.
    Returns entries in chronological order (oldest first).
    Skips corrupt JSON lines silently.
    
    Args:
        session_id: UUID to filter by
        
    Returns:
        list[dict]: List of all log records matching the session_id,
                   or empty list if no matches found.
    """
    log_dir = _get_log_dir()
    if not os.path.exists(log_dir):
        return []

    entries: list[dict] = []

    # Linear scan across all files
    for log_file in sorted(Path(log_dir).glob("*.log")):
        with open(log_file, "r", encoding="utf-8") as f:
            for line in f:
                try:
                    record = json.loads(line)
                    if record.get("session_id") == session_id:
                        entries.append(record)
                except json.JSONDecodeError:
                    continue

    return entries


# ============================================================================
# Main Execution
# ============================================================================

def run_jarvis(
    user_input: str,
    *,
    active_mode: str | None = None,
    replay_n: int | None = None,
    replay_session: bool = False
) -> None:
    """
    Execute a single interaction with the Jarvis model.
    
    Flow:
    1. Optional replay: prepend previous turns to context (not sticky)
    2. Optional mode: inject mode enforcement rules
    3. Send prompt to Ollama's "jarvis" model
    4. Log the interaction (user input, response, metadata)
    5. Print model response to stdout
    
    Replay is mutually exclusive:
    - replay_session=True: use all turns from current session
    - replay_n=N: use last N turns across all sessions
    - both False: no replay
    
    Logging captures:
    - Raw user input (before any injection)
    - Raw model response
    - Whether and how replay was used
    - Active mode (if any)
    - Session ID and timestamp
    
    Args:
        user_input: User's raw message
        active_mode: Conversation mode name (e.g., "brainstorm") or None
        replay_n: If using --replay last:N, the value N; else None
        replay_session: True if using --replay session; False otherwise
    """
    # ________________________________________________________________________
    # Step 1: Build replay context (if requested)
    # ________________________________________________________________________
    
    replay_block = ""

    if replay_session:
        entries = get_session_entries(SESSION_ID)
    elif replay_n:
        entries = get_last_n_entries(replay_n)
    else:
        entries = []

    # Format previous turns for context injection
    if entries:
        replay_lines = []
        for e in entries:
            replay_lines.append(f"User: {e['user_prompt']}")
            replay_lines.append(f"Assistant: {e['model_response']}")
        replay_block = "\n".join(replay_lines) + "\n\n"

    # ________________________________________________________________________
    # Step 2: Build final prompt
    # ________________________________________________________________________
    
    # Mode enforcement (if mode is active)
    if active_mode:
        full_prompt = f"{MODE_ENFORCEMENT}\n\n{replay_block}{user_input}".encode("utf-8")
    else:
        full_prompt = f"{replay_block}{user_input}".encode("utf-8")

    # ________________________________________________________________________
    # Step 3: Call Ollama
    # ________________________________________________________________________
    
    env = os.environ.copy()
    env["OLLAMA_NO_INTERACTIVE"] = "1"

    result = subprocess.run(
        ["ollama", "run", "jarvis"],
        input=full_prompt,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env=env
    )

    output = result.stdout.decode("utf-8", errors="ignore").strip()

    # ________________________________________________________________________
    # Step 4: Log the interaction
    # ________________________________________________________________________
    
    timestamp_iso = datetime.now().isoformat(timespec="seconds")
    _append_daily_log(
        timestamp_iso=timestamp_iso,
        session_id=SESSION_ID,
        user_prompt=user_input,
        model_response=output,
        active_mode=active_mode,
        replay_n=replay_n,
        replay_session=replay_session,
    )

    # ________________________________________________________________________
    # Step 5: Output
    # ________________________________________________________________________
    
    # Print ONLY the model response. No wrapper chatter.
    print(output)


# ============================================================================
# CLI Interface
# ============================================================================

if __name__ == "__main__":
    # ________________________________________________________________________
    # Argument Parsing
    # ________________________________________________________________________
    
    if len(sys.argv) < 2:
        print('Usage: python jarvis.py [--mode MODE] [--replay last:N|session] "your message here"', file=sys.stderr)
        sys.exit(1)

    mode_value: str | None = None
    replay_n: int | None = None
    replay_session: bool = False
    args = sys.argv[1:]

    # Parse --mode flag
    if len(args) >= 2 and args[0] == "--mode":
        mode_value = args[1]
        args = args[2:]

    # Parse --replay flag (mutually exclusive modes)
    if len(args) >= 2 and args[0] == "--replay":
        value = args[1]

        if value == "session":
            # Replay entire session
            replay_session = True

        elif value.startswith("last:"):
            # Replay last N turns
            try:
                replay_n = int(value.split(":", 1)[1])
            except ValueError:
                print("Invalid replay value. Use last:N or session", file=sys.stderr)
                sys.exit(1)

        else:
            # Invalid syntax
            print("Invalid replay value. Use last:N or session", file=sys.stderr)
            sys.exit(1)

        args = args[2:]

    # Remaining args are the user message
    user_message = " ".join(args)

    # ________________________________________________________________________
    # Execute
    # ________________________________________________________________________
    
    run_jarvis(
        user_message,
        active_mode=mode_value,
        replay_n=replay_n,
        replay_session=replay_session
    )
